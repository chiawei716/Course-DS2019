# 資料結構作業四

## 程式作業一 - solitaire.cpp

### 流程說明
1. 利用static全域變數，以字串陣列定義各牌面對應值([A ~ K]->[0 ~ 12])作為對照表
2. 使用linked list儲存牌堆，並於一開始使用 **genDeck函式** 生成一洗完的牌堆
3. 接著開始進行判斷首張卡片(以一遞減變數對應至"1"中提到的對照表)，並以執行對應動作
4. 若首張為目標卡片，使用**deleteNode函式**移除該卡片
5. 反之，則使用**moveNode函式**將其移至最後一位
6. 於每次操作前，使用 **showCards函式** 將牌堆情況打印出來，並重複到找至最後一張為止

#### isEmpty函式
用途： 
>判斷該list是否為空

作法： 
>判斷其head指標是否為NULL

#### genDeck函式
用途：
>生成洗完之牌堆

作法：
>宣告一「剩餘牌堆」並以所有十三張牌初始化之，
 接著使用rand()函式取 0 ~ (剩餘牌數-1) 間的數，
 亦即以不重複的方式在剩下的牌中隨機一張，
 將該牌依序放入待回傳的牌堆中，
 並將剛抽出的牌和後方未抽出的最後一張牌交換，
 重複至十三張牌派發完畢，接著回傳。

#### genNode函式
用途：
>利用給定值生成一新node

作法：
>宣告一Node指標，並利用給定值及空的next指標初始化之，並回傳之

#### pushNode函式
用途：
>在list最後插入新node

作法：
>在tail後方插入

#### deleteNode函式
用途：
>刪除linked list第一元素

作法：
>刪除head

#### moveNode函式
用途：
>將第一元素移至最後一位

作法：
>同時進行deleteNode及pushNode之內容

#### showCards函式
用途：
>打印linked list所有內容

作法：
>利用head作為entry，已遞迴進行遍歷至結束


## 程式作業二 - costco.cpp

### 流程說明
1. 利用一變數N儲存輸入之群組數量，並宣告相同數量之linked list
2. 使用linked list結構，並根據輸入內容儲存每個群組的成員
3. 接著以無限迴圈讀取使用者輸入內容，並判斷指令做出相對應動作
4. 若為DEQUEUE，印出list的首位成員並將其刪除
5. 若為ENQUEUE，則將其放置於適當位置
6. 若為EOF或其餘輸入，則將程式結束

*Bonus-與hw3的差異：
兩者在queue的處理上相同，皆是使用linked list做儲存，但在hw4中我將linked list的各式操作細分出來做使用，較具維護性及重複使用性。至於團體成員儲存的部分，hw3中使用的是大小為26的陣列，並藉判斷是否為空(值為一)來分辨一群組的總長，而本次作業中則亦使用linked list做儲存，可省下不必要的空間浪費。*

#### isEmpty函式
同第一題之isEmpty函式

#### isMember函式
用途：
>判斷一值是否為給定list的成員

作法：
>利用遞迴遍歷該list，並於相同時回傳true，否則false

#### genNode函式
同第一題之genNode函式

#### push函式
同第一題之pushNode函式

#### remove函式
同第一題之deleteNode函式

#### insert函式
用途：
>在指定位置插入新node

作法：
>使用輔助的Node指標變數，移動至目標位置並執行插入動作
