# 資料結構作業二

## 程式作業二 - Solitaire.cpp

### 流程說明
1. 利用static全域變數，以字串陣列定義各牌面對應值([A ~ K]->[0 ~ 12])作為對照表
2. 使用char陣列儲存牌堆，並於一開始使用 **genShuffledDeck函式** 生成一洗完的牌堆
3. 接著開始進行判斷首張卡片(以一遞增變數對應至"1"中提到的對照表)，並以circular queue結構處理卡堆
4. 若首張為目標卡片，移除該卡片，使用 **pushIndex函式** 並將front指針後推，並切換下個目標
5. 反之，則將front和rear指針後推，將整個牌堆前移（第一張移至最後一張）
6. 於每次操作前，使用 **showDeck函式** 將牌堆情況打印出來，並重複到找至最後一張為止

#### genShuffledDeck函式
用途： 
>生成隨機洗完之牌堆並回傳之。

作法： 
>宣告一「剩餘牌堆」並以所有十三張牌初始化之，
 接著使用rand()函式取 0 ~ (剩餘牌數-1) 間的數，
 亦即以不重複的方式在剩下的牌中隨機一張，
 將該牌依序放入待回傳的牌堆中，
 並將剛抽出的牌和後方未抽出的最後一張牌交換(**swap函式**)，
 重複至十三張牌派發完畢，接著回傳。

#### showDeck函式
用途：
>打印出目前剩餘牌堆。

作法：
>由於沒有使用linked list，此circular queue在刪除其中物件時並沒有進行補位，
 因此queue中的位址並不完全連續，中間存在一些已刪除的空指標。
 為此，打印方式為從front指針開始遍歷，遇到空指標則跳過，直到與rear指針重疊。

#### pushIndex函式
用途：
>推移指針。

作法：
>同showDeck函式說明所述，
 queue結構中存在空指標，因此在推移指針時需跳過空指針，
 使其最後在存在物件的指標上停下。

#### swap函式
用途：
>交換兩張卡片。

作法：
>利用 pass by reference 直接進行交換。
